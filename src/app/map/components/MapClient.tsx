"use client";

import { useState, useEffect, useRef } from "react";
import { useSearchParams } from "next/navigation";
import Link from "next/link";
import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "~/components/ui/select";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "~/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "~/components/ui/tabs";
import { Badge } from "~/components/ui/badge";
import { ScrollArea } from "~/components/ui/scroll-area";
import { ArrowLeft, Play } from "lucide-react";
import { api } from "~/trpc/react";
import RoadmapLoading from "~/components/RoadmapLoading";
import CustomMindmap from "~/components/CustomMindmap";
import DraggableWindow from "~/components/DraggableWindow";
import type { Roadmap, Topic } from "~/course-builder-ai/roadmap";

// Type for YouTube resources
interface YouTubeVideo {
  videoId: string;
  title: string;
  description: string;
  channelTitle: string;
  publishedAt: string;
  thumbnailUrl: string;
  relevanceScore: number;
  relevanceReason: string;
  url: string;
}

interface YouTubeResources {
  selectedVideos: YouTubeVideo[];
  summary: string;
  totalSearchResults: number;
}

// Type for database resource
interface DatabaseResource {
  id: string;
  title: string;
  description: string | null;
  url: string;
  type: string;
  relevanceScore: number | null;
  relevanceReason: string | null;
  thumbnailUrl: string | null;
  channelTitle: string | null;
  publishedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

// Type for project
interface Project {
  id: string;
  title: string;
  description: string;
  difficulty: "BEGINNER" | "INTERMEDIATE" | "ADVANCED";
  estimatedTime: string;
  technologies: string[];
  deliverables: string[];
  createdAt: Date;
  updatedAt: Date;
  relatedTopics: {
    id: string;
    title: string;
    summary: string;
    level: number;
  }[];
  roadmap: {
    id: string;
    title: string;
    difficulty: string;
  };
}

export default function MapClient() {
  const searchParams = useSearchParams();
  const [topic, setTopic] = useState("");
  const [difficulty, setDifficulty] = useState<"beginner" | "intermediate" | "advanced">("beginner");
  const [roadmap, setRoadmap] = useState<Roadmap | null>(null);
  const [selectedTopic, setSelectedTopic] = useState<Topic | null>(null);
  const [youtubeResources, setYoutubeResources] = useState<YouTubeResources | null>(null);
  const [projects, setProjects] = useState<Project[]>([]);
  const [isGeneratingFromUrl, setIsGeneratingFromUrl] = useState(false);
  const [extractingTopicsForVideo, setExtractingTopicsForVideo] = useState<string | null>(null);
  const hasAutoGenerated = useRef(false);
  
  // Window management state
  const [windows, setWindows] = useState({
    topicDetails: { visible: true, minimized: false },
    learningPath: { visible: true, minimized: false },
    projects: { visible: false, minimized: false }
  });

  const toggleWindow = (windowKey: keyof typeof windows, action: 'toggle' | 'minimize' | 'close') => {
    setWindows(prev => ({
      ...prev,
      [windowKey]: {
        ...prev[windowKey],
        visible: action === 'close' ? false : prev[windowKey].visible,
        minimized: action === 'minimize' ? !prev[windowKey].minimized : prev[windowKey].minimized
      }
    }));
  };

  // tRPC mutation for generating roadmap
  const generateRoadmapMutation = api.roadmap.generate.useMutation({
    onSuccess: (data) => {
      console.log("üéâ Roadmap generation success, setting roadmap data:", data.data);
      setRoadmap(data.data);
      setSelectedTopic(null);
      setIsGeneratingFromUrl(false);
      
      // Save to localStorage
      try {
        localStorage.setItem('currentRoadmap', JSON.stringify(data.data));
        console.log("‚úÖ Roadmap saved to localStorage");
      } catch (error) {
        console.warn("Failed to save roadmap to localStorage:", error);
      }
      
      console.log("‚úÖ State updated - isGeneratingFromUrl set to false");
    },
    onError: (error) => {
      console.error("‚ùå Error generating roadmap:", error);
      setIsGeneratingFromUrl(false);
    }
  });

  // tRPC mutation for fetching YouTube resources
  const fetchYoutubeResourcesMutation = api.roadmap.youtubeResources.useMutation({
    onSuccess: (data) => {
      console.log("üé• YouTube resources fetched successfully:", data.data);
      setYoutubeResources(data.data);
      
      // Save the resources to database after successful fetch
      if (selectedTopic) {
        saveYoutubeResourcesMutation.mutate({
          topicId: selectedTopic.id,
          resources: data.data.selectedVideos
        });
      }
    },
    onError: (error) => {
      console.error("‚ùå Error fetching YouTube resources:", error);
    }
  });

  // tRPC mutation for saving YouTube resources to database
  const saveYoutubeResourcesMutation = api.roadmap.saveYoutubeResources.useMutation({
    onSuccess: (data) => {
      console.log("üíæ YouTube resources saved to database:", data.data);
    },
    onError: (error) => {
      console.error("‚ùå Error saving YouTube resources:", error);
    }
  });

  // tRPC query for getting topic resources from database
  const getTopicResourcesQuery = api.roadmap.getTopicResources.useQuery(
    { 
      topicId: selectedTopic?.id ?? "",
      type: "YOUTUBE_VIDEO"
    },
    { 
      enabled: !!selectedTopic?.id,
      refetchOnWindowFocus: false
    }
  );

  // tRPC query for loading roadmap by ID
  const roadmapId = searchParams.get('roadmapId');
  const loadRoadmapQuery = api.roadmap.getRoadmapById.useQuery(
    { id: roadmapId! },
    { 
      enabled: !!roadmapId
    }
  );

  // tRPC query for getting projects for a roadmap
  const getProjectsQuery = api.roadmap.getProjects.useQuery(
    { roadmapId: roadmapId! },
    { 
      enabled: !!roadmapId,
      refetchOnWindowFocus: false
    }
  );

  // tRPC mutation for generating projects
  const generateProjectsMutation = api.roadmap.generateProjects.useMutation({
    onSuccess: (data) => {
      console.log("üöÄ Projects generated successfully:", data.data);
      // Save the generated projects to database
      if (roadmapId) {
        // Helper function to convert difficulty to uppercase enum
        const convertDifficulty = (difficulty: string): "BEGINNER" | "INTERMEDIATE" | "ADVANCED" => {
          switch (difficulty.toLowerCase()) {
            case "beginner":
              return "BEGINNER";
            case "intermediate":
              return "INTERMEDIATE";
            case "advanced":
              return "ADVANCED";
            default:
              return "BEGINNER"; // fallback
          }
        };

        saveProjectsMutation.mutate({
          roadmapId: roadmapId,
          projects: data.data.map(project => ({
            id: project.id,
            title: project.title,
            description: project.description,
            difficulty: convertDifficulty(project.difficulty),
            estimatedTime: project.estimatedTime,
            technologies: project.technologies,
            relatedTopicIds: project.relatedTopicIds,
            deliverables: project.deliverables
          }))
        });
      }
    },
    onError: (error) => {
      console.error("‚ùå Error generating projects:", error);
    }
  });

  // tRPC mutation for saving projects to database
  const saveProjectsMutation = api.roadmap.saveProjects.useMutation({
    onSuccess: (data) => {
      console.log("üíæ Projects saved to database:", data.data);
      // Refetch projects to update the UI
      void getProjectsQuery.refetch();
      // Show projects window
      setWindows(prev => ({ ...prev, projects: { visible: true, minimized: false } }));
    },
    onError: (error) => {
      console.error("‚ùå Error saving projects:", error);
    }
  });

  // Handle successful roadmap loading
  useEffect(() => {
    if (loadRoadmapQuery.data?.success) {
      console.log("üìñ Roadmap loaded from database:", loadRoadmapQuery.data.data);
      const roadmapData = loadRoadmapQuery.data.data.roadmap;
      
      // Convert parentId from null to undefined for compatibility
      const convertedRoadmap = {
        ...roadmapData,
        topics: roadmapData.topics.map(topic => ({
          ...topic,
          parentId: topic.parentId ?? undefined
        }))
      };
      
      setRoadmap(convertedRoadmap);
    }
  }, [loadRoadmapQuery.data]);

  // Handle successful projects loading
  useEffect(() => {
    if (getProjectsQuery.data?.success && getProjectsQuery.data.data) {
      console.log("üìã Projects loaded from database:", getProjectsQuery.data.data);
      const projectData = getProjectsQuery.data.data;
      if (projectData && typeof projectData === 'object' && 'projects' in projectData) {
        setProjects(projectData.projects as Project[]);
        
        // Show projects window if there are projects
        if (Array.isArray(projectData.projects) && projectData.projects.length > 0) {
          setWindows(prev => ({ ...prev, projects: { visible: true, minimized: false } }));
        }
      }
    }
  }, [getProjectsQuery.data]);

  // Initialize from URL parameters and localStorage
  useEffect(() => {
    const urlTopic = searchParams.get('topic');
    const urlDifficulty = searchParams.get('difficulty');
    const autoGenerate = searchParams.get('autoGenerate');
    const roadmapId = searchParams.get('roadmapId');

    if (urlTopic) {
      setTopic(urlTopic);
    }
    
    if (urlDifficulty && ['beginner', 'intermediate', 'advanced'].includes(urlDifficulty)) {
      setDifficulty(urlDifficulty as "beginner" | "intermediate" | "advanced");
    }

    // If roadmapId is provided, don't load from localStorage or auto-generate
    // The query hook will handle loading the roadmap from database
    if (roadmapId) {
      console.log("üîç Loading roadmap from database with ID:", roadmapId);
      return;
    }

    // Load roadmap from localStorage if no URL parameters and no roadmapId
    if (!urlTopic && !autoGenerate) {
      try {
        const savedRoadmap = localStorage.getItem('currentRoadmap');
        if (savedRoadmap) {
          const parsedRoadmap = JSON.parse(savedRoadmap) as Roadmap;
          setRoadmap(parsedRoadmap);
          console.log("‚úÖ Roadmap loaded from localStorage");
        }
      } catch (error) {
        console.warn("Failed to load roadmap from localStorage:", error);
      }
    }

    // Auto-generate roadmap if coming from course selection - only once
    if (urlTopic && urlDifficulty && autoGenerate === 'true' && !hasAutoGenerated.current && !generateRoadmapMutation.isPending) {
      hasAutoGenerated.current = true;
      setIsGeneratingFromUrl(true);
      generateRoadmapMutation.mutate({
        topic: urlTopic,
        difficulty: urlDifficulty as "beginner" | "intermediate" | "advanced"
      });
    }
  }, [searchParams, generateRoadmapMutation]);

  // Effect to load existing resources when topic is selected
  useEffect(() => {
    if (selectedTopic?.id) {
      // Clear resources immediately when topic changes
      setYoutubeResources(null);
      console.log("üîÑ Topic changed, clearing resources and checking database for:", selectedTopic.title);
    }
  }, [selectedTopic?.id, selectedTopic?.title]);

  // Effect to handle database resource loading
  useEffect(() => {
    if (getTopicResourcesQuery.data?.success) {
      const resources = getTopicResourcesQuery.data.data as DatabaseResource[];
      if (Array.isArray(resources) && resources.length > 0) {
        // Convert database resources to YouTubeResources format
        const convertedResources: YouTubeResources = {
          selectedVideos: resources.map((resource: DatabaseResource) => {
            // Extract video ID from YouTube URL
            let videoId = resource.id;
            if (resource.url.includes('youtube.com/watch?v=')) {
              const urlParams = new URLSearchParams(resource.url.split('?')[1]);
              videoId = urlParams.get('v') ?? resource.id;
            } else if (resource.url.includes('youtu.be/')) {
              videoId = resource.url.split('youtu.be/')[1]?.split('?')[0] ?? resource.id;
            }
            
            return {
              videoId,
              title: resource.title,
              description: resource.description ?? '',
              channelTitle: resource.channelTitle ?? '',
              publishedAt: resource.publishedAt?.toISOString() ?? new Date().toISOString(),
              thumbnailUrl: resource.thumbnailUrl ?? '',
              relevanceScore: resource.relevanceScore ?? 5,
              relevanceReason: resource.relevanceReason ?? '',
              url: resource.url
            };
          }),
          summary: `Found ${resources.length} saved resources for this topic`,
          totalSearchResults: resources.length
        };
        setYoutubeResources(convertedResources);
        console.log("üìö Loaded existing resources from database:", convertedResources);
      } else {
        // No existing resources found in database
        console.log("üì≠ No existing resources found in database for topic:", selectedTopic?.title);
      }
    } else if (getTopicResourcesQuery.data?.success === false) {
      console.log("‚ùå Failed to load resources from database:", getTopicResourcesQuery.data);
    }
  }, [getTopicResourcesQuery.data, selectedTopic?.title]);

  const handleGenerateRoadmap = () => {
    if (!topic.trim()) return;

    generateRoadmapMutation.mutate({ topic, difficulty });
  };

  const handleFetchResources = () => {
    if (!selectedTopic) return;
    
    // Clear previous resources when fetching new ones
    setYoutubeResources(null);
    
    fetchYoutubeResourcesMutation.mutate({
      topic: selectedTopic.title,
      difficulty: roadmap?.difficulty ?? 'beginner',
      topicSummary: selectedTopic.summary
    });
  };

  // Function to generate projects for the roadmap
  const handleGenerateProjects = () => {
    if (roadmapId) {
      generateProjectsMutation.mutate({
        roadmapId: roadmapId,
        projectCount: 6
      });
    }
  };

  const getTopicsByLevel = (level: number): Topic[] => {
    if (!roadmap) return [];
    return roadmap.topics.filter(topic => topic.level === level);
  };

  // Show full-page loading state while generating roadmap or loading from database
  console.log("üîç Checking loading state:", {
    isPending: generateRoadmapMutation.isPending,
    isGeneratingFromUrl,
    isLoadingRoadmap: loadRoadmapQuery.isLoading,
    hasRoadmap: !!roadmap,
    roadmapTitle: roadmap?.title,
    roadmapId: searchParams.get('roadmapId')
  });
  
  // Show loading if we don't have a roadmap yet AND we're either:
  // 1. Generating a new roadmap (pending or generating from URL)
  // 2. Loading an existing roadmap from database
  if (!roadmap && (generateRoadmapMutation.isPending || isGeneratingFromUrl || loadRoadmapQuery.isLoading)) {
    console.log("üîÑ Showing loading state");
    return (
      <div className="container mx-auto p-6">
        <div className="flex items-center space-x-4 mb-6">
          <Link href="/library">
            <Button variant="ghost" size="sm">
              <ArrowLeft className="h-4 w-4 mr-2" />
              Back to Library
            </Button>
          </Link>
        </div>
        <RoadmapLoading topic={topic} difficulty={difficulty} />
      </div>
    );
  }

  console.log("üñ•Ô∏è Rendering main content");

  return (
    <div className={`${roadmap ? 'h-screen overflow-hidden' : 'container mx-auto p-6'} space-y-6`}>
      {/* Header - Only show when no roadmap */}
      {!roadmap && (
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <Link href="/library">
              <Button variant="ghost" size="sm">
                <ArrowLeft className="h-4 w-4 mr-2" />
                Back to Library
              </Button>
            </Link>
          </div>
          
          <div className="text-center space-y-2">
            <h1 className="text-3xl font-bold">Learning Roadmap Generator</h1>
            <p className="text-muted-foreground">Generate interactive mindmaps for any learning topic</p>
          </div>
          
          <div className="w-24" /> {/* Spacer for centering */}
        </div>
      )}

      {/* Input Section - Only show when not auto-generating and no roadmap */}
      {!searchParams.get('autoGenerate') && !roadmap && (
        <div className="container mx-auto px-6">
          <Card>
            <CardHeader>
              <CardTitle>Create Your Learning Roadmap</CardTitle>
              <CardDescription>Enter a topic and difficulty level to generate a comprehensive roadmap</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div className="md:col-span-2 space-y-2">
                  <Label htmlFor="topic">Learning Topic</Label>
                  <Input
                    id="topic"
                    placeholder="e.g., Machine Learning, Web Development, Data Science"
                    value={topic}
                    onChange={(e) => setTopic(e.target.value)}
                    onKeyDown={(e) => e.key === "Enter" && handleGenerateRoadmap()}
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="difficulty">Difficulty Level</Label>
                  <Select value={difficulty} onValueChange={(value: "beginner" | "intermediate" | "advanced") => setDifficulty(value)}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="beginner">Beginner</SelectItem>
                      <SelectItem value="intermediate">Intermediate</SelectItem>
                      <SelectItem value="advanced">Advanced</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              <Button 
                onClick={handleGenerateRoadmap} 
                disabled={generateRoadmapMutation.isPending ?? !topic.trim()}
                className="w-full"
              >
                {generateRoadmapMutation.isPending ? "Generating Roadmap..." : "Generate Roadmap"}
              </Button>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Results Section */}
      {generateRoadmapMutation.isError && (
        <div className="container mx-auto px-6">
          <Card className="border-red-200 bg-red-50 dark:border-red-800 dark:bg-red-950">
            <CardHeader>
              <CardTitle className="text-red-800 dark:text-red-200">Error Generating Roadmap</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-red-700 dark:text-red-300">
                {generateRoadmapMutation.error?.message ?? "Something went wrong while generating your roadmap. Please try again."}
              </p>
              <Button 
                variant="outline" 
                onClick={() => generateRoadmapMutation.reset()}
                className="mt-4"
              >
                Try Again
              </Button>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Error loading roadmap from database */}
      {loadRoadmapQuery.isError && (
        <div className="container mx-auto px-6">
          <Card className="border-red-200 bg-red-50 dark:border-red-800 dark:bg-red-950">
            <CardHeader>
              <CardTitle className="text-red-800 dark:text-red-200">Error Loading Roadmap</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-red-700 dark:text-red-300">
                {loadRoadmapQuery.error?.message ?? "Failed to load the requested roadmap. It may have been deleted or you don't have access to it."}
              </p>
              <div className="flex gap-2 mt-4">
                <Button 
                  variant="outline" 
                  onClick={() => loadRoadmapQuery.refetch()}
                >
                  Try Again
                </Button>
                <Link href="/library">
                  <Button variant="outline">
                    Back to Library
                  </Button>
                </Link>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Mindmap Canvas - Full screen freeform canvas */}
      {roadmap && (
        <div className="fixed inset-0 bg-background overflow-hidden">
          {/* Floating Header */}
          <div className="absolute top-4 left-1/2 transform -translate-x-1/2 z-50">
            <Card className="px-6 py-3 shadow-lg bg-background/95 backdrop-blur-sm">
              <div className="text-center space-y-2">
                <h1 className="text-xl font-bold">{roadmap.title}</h1>
                <p className="text-sm text-muted-foreground">{roadmap.description}</p>
                <Badge variant="outline" className="text-xs">
                  {roadmap.difficulty}
                </Badge>
              </div>
            </Card>
          </div>

          {/* Back Button */}
          <div className="absolute top-4 left-4 z-50">
            <Link href="/library">
              <Button variant="ghost" size="sm" className="bg-background/95 backdrop-blur-sm">
                <ArrowLeft className="h-4 w-4 mr-2" />
                Back to Library
              </Button>
            </Link>
          </div>

          {/* Main Mindmap Canvas */}
          <div className="absolute inset-0">
            <CustomMindmap 
              roadmap={roadmap} 
              onTopicSelect={(topic) => {
                console.log("üéØ Topic selected:", topic.title, "ID:", topic.id);
                setSelectedTopic(topic);
                // Resources will be loaded automatically via the useEffect hook
              }}
              selectedTopic={selectedTopic}
            />
          </div>

          {/* Draggable Windows */}
          
          {/* Topic Details Window */}
          {windows.topicDetails.visible && (
            <DraggableWindow
              title="Topic Details"
              initialPosition={{ x: 800, y: 100 }}
              initialSize={{ width: 400, height: 600 }}
              isMinimized={windows.topicDetails.minimized}
              onMinimize={() => toggleWindow('topicDetails', 'minimize')}
              onClose={() => toggleWindow('topicDetails', 'close')}
            >
              {selectedTopic ? (
                <div className="space-y-4">
                  <div>
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="font-semibold">{selectedTopic.title}</h3>
                      <Badge variant="secondary">Level {selectedTopic.level}</Badge>
                    </div>
                    <p className="text-sm text-muted-foreground">{selectedTopic.summary}</p>
                  </div>
                  
                  {selectedTopic.children.length > 0 && (
                    <div>
                      <Label className="text-sm font-medium">Related Topics:</Label>
                      <div className="flex flex-wrap gap-1 mt-2">
                        {selectedTopic.children.map((childId) => {
                          const childTopic = roadmap.topics.find(t => t.id === childId);
                          return childTopic ? (
                            <Badge 
                              key={childId} 
                              variant="outline" 
                              className="cursor-pointer hover:bg-primary hover:text-primary-foreground"
                              onClick={() => setSelectedTopic(childTopic)}
                            >
                              {childTopic.title}
                            </Badge>
                          ) : null;
                        })}
                      </div>
                    </div>
                  )}
                  
                  <div className="pt-2">
                    {/* Show loading state when checking for existing resources */}
                    {getTopicResourcesQuery.isLoading && (
                      <div className="flex items-center justify-center text-sm text-muted-foreground p-4">
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary mr-2"></div>
                        Checking for existing resources...
                      </div>
                    )}
                    
                    {/* Show fetch button only if no resources exist and not loading from database */}
                    {!youtubeResources && !getTopicResourcesQuery.isLoading && (
                      <Button 
                        size="sm" 
                        className="w-full"
                        onClick={handleFetchResources}
                        disabled={fetchYoutubeResourcesMutation.isPending}
                      >
                        {fetchYoutubeResourcesMutation.isPending ? "Fetching Resources..." : "Fetch New Resources"}
                      </Button>
                    )}
                    
                    {/* Show refresh button if resources already exist */}
                    {youtubeResources && !getTopicResourcesQuery.isLoading && (
                      <Button 
                        size="sm" 
                        variant="outline"
                        className="w-full"
                        onClick={handleFetchResources}
                        disabled={fetchYoutubeResourcesMutation.isPending}
                      >
                        {fetchYoutubeResourcesMutation.isPending ? "Refreshing Resources..." : "Refresh Resources"}
                      </Button>
                    )}
                  </div>

                  {/* YouTube Resources Section */}
                  {youtubeResources && (
                    <div className="border-t pt-4 space-y-3">
                      <div className="flex items-center justify-between">
                        <Label className="text-sm font-medium">YouTube Resources:</Label>
                        <Badge variant="secondary" className="text-xs">
                          {youtubeResources.summary.includes('saved') ? 'Saved' : 'Fresh'}
                        </Badge>
                      </div>
                      <ScrollArea className="h-64">
                        <div className="space-y-2">
                          {youtubeResources.selectedVideos.map((video) => (
                            <div key={video.videoId} className="border rounded-lg p-3 space-y-2">
                              <div className="flex items-start space-x-3">
                                {/* YouTube Icon */}
                                <div className="flex-shrink-0 mt-0.5">
                                  <Play className="h-4 w-4 text-red-600 fill-red-600" />
                                </div>
                                
                                {/* Video Info */}
                                <div className="flex-1 min-w-0 space-y-1">
                                  <h4 
                                    className={`font-medium text-sm line-clamp-2 cursor-pointer hover:text-blue-600 hover:underline transition-colors ${
                                      extractingTopicsForVideo === video.videoId ? 'opacity-50 cursor-wait' : ''
                                    }`}
                                    onClick={async () => {
                                      // Prevent multiple clicks while extracting
                                      if (extractingTopicsForVideo === video.videoId) return;
                                      
                                      // Create a special contentId for YouTube videos
                                      const contentId = `youtube_${video.videoId}`;
                                      
                                      // Store video data in localStorage for the learn page
                                      const contentData = {
                                        content_id: contentId,
                                        content_type: 'youtube' as const,
                                        title: video.title,
                                        url: video.url,
                                        text_length: video.description?.length ?? 0,
                                        text_preview: video.description?.substring(0, 200) ?? '',
                                        status: 'completed'
                                      };
                                      
                                      localStorage.setItem(`content_${contentId}`, JSON.stringify(contentData));
                                      
                                      // Check if topics already exist for this video
                                      const existingTopics = localStorage.getItem(`topics_${contentId}`);
                                      
                                      if (!existingTopics) {
                                        // Set loading state for this specific video
                                        setExtractingTopicsForVideo(video.videoId);
                                        console.log("üéØ Extracting topics for YouTube video before navigation...");
                                        
                                        try {
                                          // Use fetch to call the API directly since we're in an event handler
                                          const response = await fetch('/api/trpc/content.extractYoutubeTopics', {
                                            method: 'POST',
                                            headers: {
                                              'Content-Type': 'application/json',
                                            },
                                            body: JSON.stringify({
                                              json: {
                                                url: video.url,
                                                title: video.title
                                              }
                                            })
                                          });

                                          if (response.ok) {
                                            // @ts-ignore - Temporarily disable TS for debugging
                                            const result = await response.json();
                                            
                                            console.log("üîç Raw API response:", JSON.stringify(result, null, 2));
                                            
                                            // Handle different response structures
                                            let topics = null;
                                            try {
                                              if (result.result?.data?.json?.data?.topics) {
                                                topics = result.result.data.json.data.topics;
                                                console.log("‚úÖ Found topics in structure: result.result.data.json.data.topics");
                                              } else if (result.result?.data?.success && result.result.data.data?.topics) {
                                                topics = result.result.data.data.topics;
                                                console.log("‚úÖ Found topics in structure: result.result.data.data.topics");
                                              } else if (result.result?.data?.topics) {
                                                topics = result.result.data.topics;
                                                console.log("‚úÖ Found topics in structure: result.result.data.topics");
                                              } else if (result.result?.topics) {
                                                topics = result.result.topics;
                                                console.log("‚úÖ Found topics in structure: result.result.topics");
                                              } else {
                                                console.log("‚ùå Could not find topics in any expected structure");
                                                console.log("Available keys in result:", Object.keys(result));
                                                if (result.result) {
                                                  console.log("Available keys in result.result:", Object.keys(result.result));
                                                  if (result.result.data) {
                                                    console.log("Available keys in result.result.data:", Object.keys(result.result.data));
                                                    if (result.result.data.json) {
                                                      console.log("Available keys in result.result.data.json:", Object.keys(result.result.data.json));
                                                      if (result.result.data.json.data) {
                                                        console.log("Available keys in result.result.data.json.data:", Object.keys(result.result.data.json.data));
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            } catch (e) {
                                              console.error("‚ùå Error parsing response structure:", e);
                                            }
                                            
                                            if (topics && Array.isArray(topics)) {
                                              console.log("üéØ Processing", topics.length, "topics");
                                              // Transform topics data to match expected format
                                              const topicsData = {
                                                topics: topics.map((topic, index) => ({
                                                  topic_name: topic.topic_name ?? '',
                                                  topic_page_start: index + 1,
                                                  topic_page_end: index + 1,
                                                  topic_summary: topic.topic_summary ?? ''
                                                }))
                                              };
                                              
                                              localStorage.setItem(`topics_${contentId}`, JSON.stringify(topicsData));
                                              console.log("‚úÖ Topics extracted and saved to localStorage before navigation:", topicsData.topics.length, "topics");
                                              console.log("üîë localStorage key used:", `topics_${contentId}`);
                                              console.log("üìù Topics data saved:", JSON.stringify(topicsData, null, 2));
                                              
                                              // Verify the data was saved correctly
                                              const verifyData = localStorage.getItem(`topics_${contentId}`);
                                              console.log("üîç Verification - data in localStorage:", verifyData ? "Found" : "Not found");
                                              
                                              // Add a small delay to ensure localStorage operation is complete
                                              await new Promise(resolve => setTimeout(resolve, 100));
                                              
                                              // Navigate to learn page after topics are successfully extracted and saved
                                              window.open(`/learn/${contentId}`, '_blank');
                                            } else {
                                              console.warn("‚ö†Ô∏è Topic extraction failed, proceeding without topics");
                                              // Navigate anyway
                                              window.open(`/learn/${contentId}`, '_blank');
                                            }
                                          } else {
                                            console.warn("‚ö†Ô∏è API call failed, proceeding without topics");
                                            // Navigate anyway
                                            window.open(`/learn/${contentId}`, '_blank');
                                          }
                                        } catch (error) {
                                          console.warn("‚ö†Ô∏è Failed to extract topics, proceeding without them:", error);
                                          // Navigate anyway even if extraction fails
                                          window.open(`/learn/${contentId}`, '_blank');
                                        } finally {
                                          // Clear loading state
                                          setExtractingTopicsForVideo(null);
                                        }
                                      } else {
                                        console.log("üìö Topics already exist for this video, using cached version");
                                        // Navigate immediately since topics already exist
                                        window.open(`/learn/${contentId}`, '_blank');
                                      }
                                    }}
                                  >
                                    {extractingTopicsForVideo === video.videoId ? (
                                      <span className="flex items-center gap-2">
                                        <div className="animate-spin rounded-full h-3 w-3 border-2 border-blue-600 border-t-transparent"></div>
                                        Extracting topics...
                                      </span>
                                    ) : (
                                      video.title
                                    )}
                                  </h4>
                                  <p className="text-xs text-muted-foreground">{video.channelTitle}</p>
                                  <div className="flex items-center gap-2">
                                    <Badge variant="outline" className="text-xs">
                                      Score: {video.relevanceScore}/10
                                    </Badge>
                                    {extractingTopicsForVideo === video.videoId && (
                                      <Badge variant="outline" className="text-xs bg-blue-100 text-blue-800">
                                        Processing...
                                      </Badge>
                                    )}
                                  </div>
                                </div>
                              </div>
                              
                              <p className="text-xs text-muted-foreground line-clamp-2 ml-7">
                                {video.relevanceReason}
                              </p>
                            </div>
                          ))}
                        </div>
                      </ScrollArea>
                      <div className="text-xs text-muted-foreground">
                        {youtubeResources.summary}
                      </div>
                    </div>
                  )}

                  {/* Error state for resources */}
                  {fetchYoutubeResourcesMutation.isError && (
                    <div className="border-t pt-4">
                      <div className="text-sm text-red-500">
                        Error: {fetchYoutubeResourcesMutation.error?.message}
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                <div className="text-center text-muted-foreground">
                  <p>Click on any node in the mindmap to see detailed information</p>
                </div>
              )}
            </DraggableWindow>
          )}

          {/* Roadmap Overview Window */}
          {windows.learningPath.visible && (
            <DraggableWindow
              title="Roadmap Overview"
              initialPosition={{ x: 50, y: 100 }}
              initialSize={{ width: 350, height: 400 }}
              isMinimized={windows.learningPath.minimized}
              onMinimize={() => toggleWindow('learningPath', 'minimize')}
              onClose={() => toggleWindow('learningPath', 'close')}
            >
              <Tabs defaultValue="level0" className="w-full">
                <TabsList className="grid grid-cols-4 w-full">
                  {[0, 1, 2, 3].map((level) => {
                    const topicsAtLevel = getTopicsByLevel(level);
                    return topicsAtLevel.length > 0 ? (
                      <TabsTrigger key={level} value={`level${level}`}>
                        L{level} ({topicsAtLevel.length})
                      </TabsTrigger>
                    ) : null;
                  })}
                </TabsList>
                
                {[0, 1, 2, 3].map((level) => {
                  const topicsAtLevel = getTopicsByLevel(level);
                  return topicsAtLevel.length > 0 ? (
                    <TabsContent key={level} value={`level${level}`}>
                      <ScrollArea className="h-[280px]">
                        <div className="space-y-2">
                          {topicsAtLevel.map((topic) => (
                            <div 
                              key={topic.id}
                              className="p-3 border rounded-lg cursor-pointer hover:bg-muted/50 transition-colors"
                              onClick={() => setSelectedTopic(topic)}
                            >
                              <div className="font-medium text-sm">{topic.title}</div>
                              <div className="text-xs text-muted-foreground mt-1 line-clamp-2">
                                {topic.summary}
                              </div>
                            </div>
                          ))}
                        </div>
                      </ScrollArea>
                    </TabsContent>
                  ) : null;
                })}
              </Tabs>
              
              {/* Generate Projects Button */}
              {projects.length === 0 && !generateProjectsMutation.isPending && roadmapId && (
                <div className="mt-4 pt-4 border-t">
                  <Button 
                    onClick={handleGenerateProjects}
                    className="w-full"
                    size="sm"
                  >
                    Generate Learning Projects
                  </Button>
                </div>
              )}
              
              {/* Loading state for project generation */}
              {generateProjectsMutation.isPending && (
                <div className="mt-4 pt-4 border-t">
                  <div className="flex items-center justify-center text-sm text-muted-foreground p-4">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary mr-2"></div>
                    Generating projects...
                  </div>
                </div>
              )}
              
              {/* Show projects button if projects exist */}
              {projects.length > 0 && !windows.projects.visible && (
                <div className="mt-4 pt-4 border-t">
                  <Button 
                    onClick={() => setWindows(prev => ({ ...prev, projects: { visible: true, minimized: false } }))}
                    className="w-full"
                    size="sm"
                    variant="outline"
                  >
                    Show Projects ({projects.length})
                  </Button>
                </div>
              )}
            </DraggableWindow>
          )}

          {/* Projects Window */}
          {windows.projects.visible && (
            <DraggableWindow
              title="Learning Projects"
              initialPosition={{ x: 400, y: 100 }}
              initialSize={{ width: 500, height: 600 }}
              isMinimized={windows.projects.minimized}
              onMinimize={() => toggleWindow('projects', 'minimize')}
              onClose={() => toggleWindow('projects', 'close')}
            >
              {projects.length > 0 ? (
                <ScrollArea className="h-[500px]">
                  <div className="space-y-4">
                    {projects.map((project) => (
                      <div key={project.id} className="border rounded-lg p-4 space-y-3">
                        {/* Project Header */}
                        <div className="flex items-start justify-between">
                          <h4 className="font-semibold text-lg">{project.title}</h4>
                          <Badge 
                            variant={
                              project.difficulty === 'BEGINNER' ? 'default' :
                              project.difficulty === 'INTERMEDIATE' ? 'secondary' : 'destructive'
                            }
                          >
                            {project.difficulty}
                          </Badge>
                        </div>
                        
                        {/* Project Description */}
                        <p className="text-sm text-muted-foreground">{project.description}</p>
                        
                        {/* Project Details */}
                        <div className="grid grid-cols-1 gap-3">
                          <div>
                            <Label className="text-xs font-medium">Estimated Time:</Label>
                            <p className="text-sm">{project.estimatedTime}</p>
                          </div>
                          
                          <div>
                            <Label className="text-xs font-medium">Technologies:</Label>
                            <div className="flex flex-wrap gap-1 mt-1">
                              {project.technologies.map((tech, index) => (
                                <Badge key={index} variant="outline" className="text-xs">
                                  {tech}
                                </Badge>
                              ))}
                            </div>
                          </div>
                          
                          <div>
                            <Label className="text-xs font-medium">Related Topics:</Label>
                            <div className="flex flex-wrap gap-1 mt-1">
                              {project.relatedTopics.map((topic) => (
                                <Badge 
                                  key={topic.id} 
                                  variant="secondary" 
                                  className="text-xs cursor-pointer hover:bg-primary hover:text-primary-foreground"
                                  onClick={() => {
                                    const fullTopic = roadmap?.topics.find(t => t.id === topic.id);
                                    if (fullTopic) {
                                      setSelectedTopic(fullTopic);
                                    }
                                  }}
                                >
                                  {topic.title}
                                </Badge>
                              ))}
                            </div>
                          </div>
                          
                          <div>
                            <Label className="text-xs font-medium">Deliverables:</Label>
                            <ul className="text-sm mt-1 space-y-1">
                              {project.deliverables.map((deliverable, index) => (
                                <li key={index} className="flex items-start">
                                  <span className="mr-2 text-primary">‚Ä¢</span>
                                  {deliverable}
                                </li>
                              ))}
                            </ul>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </ScrollArea>
              ) : (
                <div className="text-center text-muted-foreground p-8">
                  <p>No projects generated yet.</p>
                  <p className="text-sm mt-2">Generate projects from the Roadmap Overview to get started!</p>
                </div>
              )}
            </DraggableWindow>
          )}

          {/* Floating Action Buttons for reopening closed windows */}
          <div className="absolute bottom-4 right-4 flex flex-col space-y-2">
            {!windows.topicDetails.visible && (
              <Button
                size="sm"
                onClick={() => setWindows(prev => ({ ...prev, topicDetails: { visible: true, minimized: false } }))}
              >
                Show Topic Details
              </Button>
            )}
            {!windows.learningPath.visible && (
              <Button
                size="sm"
                onClick={() => setWindows(prev => ({ ...prev, learningPath: { visible: true, minimized: false } }))}
              >
                Show Roadmap
              </Button>
            )}
            {!windows.projects.visible && projects.length > 0 && (
              <Button
                size="sm"
                onClick={() => setWindows(prev => ({ ...prev, projects: { visible: true, minimized: false } }))}
              >
                Show Projects
              </Button>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
